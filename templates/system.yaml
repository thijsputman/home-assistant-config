- binary_sensor:
    # Power outage detection based on back-up UPS. To filter out minor hiccups,
    # this triggers when the UPS is discharging and battery level dips below
    # 98%. Under current load this happens after about 40 seconds...
    # If the battery charge sensor is unavailable, assume it to be at 100%-
    # charge. A false-positive on the power outage sensor might have rather
    # severe consequences, so err on the side of caution.
    - name: Power outage
      unique_id: 679eb3a5-4052-445c-979c-a72cb5796048
      device_class: problem
      icon: mdi:transmission-tower
      availability: >-
        {{ states('sensor.ups_status') not in ['unknown', 'unavailable'] }}
      state: >-
        {%- if
          states('sensor.ups_battery_charge')|int(100) < 98 and
          states('sensor.ups_status') == 'On Battery Battery Discharging'
        -%}
          on
        {%- else -%}
          off
        {%- endif -%}
# JSON-encoded list of failed devices – renders every 5 minutes. The list is
# sorted and deduplicated so this sensor's state only changes if a device
# becomes (un)available. Device can be either "native" Home Assistant devices
# or manual groups of related sensors (either template-entities or sensors added
# by integrations that don't provide devices).
- trigger:
    - platform: time_pattern
      hours: "*"
      minutes: /5
      seconds: 0
  sensor:
    - name: Failed devices
      unique_id: b35c9d1a-715b-4216-a620-6308c47e0e8f
      icon: mdi:toy-brick-remove-outline
      # Find all "devices" that have one or more entities in the "unavailable"-,
      # "unknown"- or "none"-state. If an actual device is not available, we
      # attempt to manually group the sensor(s). Only if we're unable to group
      # are the individual sensors included in the list.
      state: >-
        {% set result = namespace(devices=[]) %}
        {%
          set entity_ids = states |
          selectattr('state', 'in',
            [
              'unavailable',
              'unknown',
              'none'
            ]
          ) |
          rejectattr('entity_id', 'match', '(scene|button)\.') |
          map(attribute='entity_id') | list
        %}
        {% for entity_id in entity_ids %}
          {% set matched = 'unknown' %}
          {# Individual entities (not part of a device) #}
          {% if device_id(entity_id) == None %}
            {# WeeWX #}
            {% if entity_id is search('^sensor\.weewx_.+') %}
              {#
                Ignore wind direction sensors; they become unavailable if wind
                speed equals zero
              #}
              {% if entity_id is not search('_wind_.*direction') %}
                {% set matched = 'WeeWX' %}
              {% endif %}
            {# Aarlo #}
            {% elif entity_id is search('^(?:binary_|)sensor\.aarlo_.+') %}
              {#
                The "recent activity"-sensors appear to initialise "unknown" if
                Home Assistant is restarted while the cameras are inactive...
              #}
              {% if entity_id is not
                search('sensor\.aarlo_recent_activity_.+')
              %}
                {% set matched = 'Aarlo' %}
              {% endif %}
            {# tadoº #}
            {% elif entity_id is search('^sensor\.tado_smart_.+') %}
              {# Ignored; derived from HomeKit Controller #}
            {# Gammu #}
            {% elif entity_id is search('^sensor\.gammu_.+') %}
              {# Only signal-strength is always available #}
              {% if entity_id == 'sensor.gammu_signal_strength' %}
                {% set matched = 'Gammu' %}
              {% endif %}
            {# Afvalwijzer #}
            {% elif entity_id is search('^sensor\.afvalwijzer_.+') %}
              {#
                Turns out Afvalwijzer only adds next year's data towards the end
                of the current calendar year – as a result, over the course of
                December some sensors run out of data and become "none"/
                "unavailable"... Solution for now is to ignore Afvalwijzer
                failures in December.
              #}
              {%
                if entity_id is not search('(today|tomorrow)') and
                  now().month != 12
              %}
                {% set matched = 'Afvalwijzer' %}
              {% endif %}
            {# Hue scene heuristic #}
            {% elif entity_id is search('^sensor\.hue_scene_.+') %}
              {% set matched = 'Hue scene heuristic' %}
            {# Last notification #}
            {% elif entity_id is search('^sensor\.last_notification_.+') %}
              {# Ignored; unavailable as part of normal operation #}
            {# Prusa MINI+ (template sensor) #}
            {% elif entity_id == 'sensor.prusa_mini_job_name' %}
              {# Ignored; only available when in-use #}
            {# Water consumption #}
            {% elif entity_id is search('^sensor\.flow_.+_statistics') %}
              {#
                Ignored; statistics sensors report unknown when no data is
                available to compute the requested statistic
              #}
            {# Failed devices (this sensor) #}
            {% elif entity_id == 'sensor.failed_devices' %}
              {# Ignored #}
            {# Others; ungrouped #}
            {% else %}
              {% set matched = state_attr(entity_id, 'friendly_name') %}
            {% endif %}
          {# Devices #}
          {% else %}
            {# Mobile App #}
            {%
              if entity_id is search(
                '^sensor\..+_(charger_type|next_alarm|do_not_disturb_sensor)$'
              )
            %}
              {# Ignored; unavailable/unknown under normal circumstances #}
            {# Meater #}
            {% elif entity_id is search('^sensor\.meater_probe_.+') %}
              {# Ignored; only available when in-use #}
            {# Prusa MINI+ #}
            {% elif entity_id is search('.+\.prusa_mini_.+') %}
              {# Ignored; only available when in-use #}
            {# Fully Kiosk Browser #}
            {%
              elif entity_id is search('^number\..+_screen(|saver)_brightness')
            %}
              {# Ignored; unavailable/unknown when screen switched off #}
            {# Phoscon Hive #}
            {% elif entity_id == 'light.extended_color_light_23' %}
              {# Ignored; only available when switched on #}
            {% else %}
              {% set matched = device_attr(device_id(entity_id), 'name') %}
            {% endif %}
          {% endif %}
          {% set result.devices = result.devices + [matched] %}
        {% endfor %}
        {#
          A state's value can be at most 255 characters. Truncate JSON output to
          245 characters and append a "closing" ellipsis – the regex is used to
          cope with the edge cases where the brute force replace causes invalid
          JSON...
          Not very graceful, but given the limited control structures available
          in Jinja the below is much simpler than trying to properly implement
          this in the preceding for-loop.
        #}
        {{
          result.devices | reject('eq', 'unknown') |
            unique | list | sort | to_json |
            truncate(245, true, '..."]') |
            regex_replace('",? ?"?\.\.\."]$', '..."]')
        }}
