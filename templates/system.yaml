- binary_sensor:
    # Power outage detection based on back-up UPS. To filter out minor hiccups,
    # this triggers when the UPS is discharging and battery level dips below
    # 98%. Under current load this happens after about 40 seconds...
    - name: Power outage
      unique_id: 679eb3a5-4052-445c-979c-a72cb5796048
      device_class: problem
      icon: mdi:transmission-tower
      availability: >-
        {{ states('sensor.ups_status') not in ['unknown', 'unavailable'] }}
      state: >-
        {%- if
          states('sensor.ups_battery_charge')|int < 98 and
          states('sensor.ups_status') == 'On Battery Battery Discharging'
        -%}
          on
        {%- else -%}
          off
        {%- endif -%}
# JSON-encoded list of failed devices – renders every 5 minutes. The list is
# sorted and deduplicated so this sensor's state only changes if a device
# becomes (un)available. Device can be either "native" Home Assistant devices
# or manual groups of related sensors (either template-entities or sensors added
# by integrations that don't provide devices).
- trigger:
    - platform: time_pattern
      hours: "*"
      minutes: /5
      seconds: 0
  sensor:
    - name: Failed devices
      unique_id: b35c9d1a-715b-4216-a620-6308c47e0e8f
      icon: mdi:toy-brick-remove-outline
      # Find all "devices" that have one or more entities in the "unavailable"-,
      # "unknown"- or "none"-state. If an actual device is not available, we
      # attempt to manually group the sensor(s). Only if we're unable to group
      # are the individual sensors included in the list.
      state: >-
        {% set result = namespace(devices=[]) %}
        {%
          set entity_ids = states |
          selectattr('state', 'in',
            [
              'unavailable',
              'unknown',
              'none'
            ]
          ) |
          rejectattr('entity_id', 'match', 'scene\.') |
          map(attribute='entity_id') | list
        %}
        {% for entity_id in entity_ids %}
          {% set matched = 'unknown' %}
          {% if device_id(entity_id) == None %}
            {# WeeWX #}
            {% if entity_id is search('^sensor\.weewx_.+') %}
              {#
                Ignore wind direction sensors; they become unavailable if wind
                speed equals zero
              #}
              {% if entity_id is not search('_wind_.*direction') %}
                {% set matched = 'WeeWX' %}
              {% endif %}
            {# Pi4 #}
            {% elif entity_id is search('^sensor\.pi4_.+') %}
              {% if entity_id is search('_sandbox_') %}
                {% set matched = 'Pi4 Sandbox' %}
              {% else %}
                {% set matched = 'Pi4' %}
              {% endif %}
            {# Aarlo #}
            {% elif entity_id is search('^(?:binary_|)sensor\.aarlo_.+') %}
              {#
                The "recent activity"-sensors appear to initialise "unknown" if
                Home Assistant is restarted while the cameras are inactive...
              #}
              {% if entity_id is not
                search('sensor\.aarlo_recent_activity_.+')
              %}
                {% set matched = 'Aarlo' %}
              {% endif %}
            {# tadoº #}
            {% elif entity_id is search('^sensor.tado_smart_.+') %}
              {# Ignored; derived from HomeKit Controller #}
            {# Gammu #}
            {% elif entity_id is search('^sensor\.gammu_.+') %}
              {# Only signal-strength is always available #}
              {% if entity_id == 'sensor.gammu_signal_strength' %}
                {% set matched = 'Gammu' %}
              {% endif %}
            {# Afvalwijzer #}
            {% elif entity_id is search('^sensor\.afvalwijzer_.+') %}
              {#
                Turns out Afvalwijzer only adds next year's data towards the end
                of the current calendar year – as a result, over the course of
                December some sensors run out of data and become "none"/
                "unavailable"... Solution for now is to ignore Afvalwijzer
                failures in December.
              #}
              {%
                if entity_id is not search('(today|tomorrow)') and
                  now().month != 12
              %}
                {% set matched = 'Afvalwijzer' %}
              {% endif %}
            {# Hue scene heuristic #}
            {% elif entity_id is search('^sensor\.hue_scene_.+') %}
              {% set matched = 'Hue scene heuristic' %}
            {# Plant sensors #}
            {% elif entity_id is search('^plant\..+') %}
              {# Ignored; derived from MQTT devices #}
            {# Failed devices (this sensor) #}
            {% elif entity_id == 'sensor.failed_devices' %}
              {# Ignored #}
            {# Others; ungrouped #}
            {% else %}
              {% set matched = state_attr(entity_id, 'friendly_name') %}
            {% endif %}
          {% else %}
            {#
              Several "Mobile App"-related sensors can be unavailable/unknown
              under normal circumstances; these entity IDs are ignored...
            #}
            {%
              if entity_id is not search(
                '^sensor\..+_(charger_type|next_alarm|do_not_disturb_sensor)$'
              )
            %}
              {% set matched = device_attr(device_id(entity_id), 'name') %}
            {% endif %}
          {% endif %}
          {% set result.devices = result.devices + [matched] %}
        {% endfor %}
        {#
          A state's value can be at most 255 characters. Truncate JSON output to
          245 characters and append a "closing" ellipsis – the regex is used to
          cope with the edge cases where the brute force replace causes invalid
          JSON...
          Not very graceful, but given the limited control structures available
          in Jinja the below is much simpler than trying to properly implement
          this in the preceding for-loop.
        #}
        {{
          result.devices | reject('eq', 'unknown') |
            unique | list | sort | to_json |
            truncate(245, true, '..."]') |
            regex_replace('",? ?"?\.\.\."]$', '..."]')
        }}
# If the Home Alarm is in "Armed away"-mode for more than 16 hours, enable
# Vacation-mode – indicating we are away from home longer than on a regular
# working day.
# This mainly serves to make some of the alarm triggers stricter (a false alarm
# when coming home from a trip is less of an issue than one that can occur daily
# coming home from the office), but it has other potential uses too.
# Triggers at the top of every hour (and on Home Alarm disarm) to prevent
# unnecessarily rendering a not highly time-sensitive template.
- trigger:
    - platform: time_pattern
      hours: /1
      minutes: 0
      seconds: 0
    - platform: state
      entity_id: alarm_control_panel.home_alarm
      to: disarmed
  binary_sensor:
    - name: Vacation-mode
      unique_id: b2d979d7-3a12-4722-92e4-64773edbb939
      icon: mdi:airplane-clock
      state: >-
        {%
          if states.alarm_control_panel.home_alarm.last_changed is defined
        %}
          {{
            states('alarm_control_panel.home_alarm') == 'armed_away' and
            states.alarm_control_panel.home_alarm.last_changed <
              now() - timedelta(hours=16)
          }}
        {# Err on the side of caution #}
        {% elif states('alarm_control_panel.home_alarm') == 'armed_away' %}
          true
        {% else %}
          false
        {% endif %}
