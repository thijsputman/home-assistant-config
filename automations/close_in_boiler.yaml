- alias: ðŸŒ¡ï¸ | â° Close-in boiler off (daily after 22:00)
  description: ''
  trigger:
  - platform: time
    at: "22:00"
  condition:
  - condition: state
    entity_id: switch.smart_plug_9
    state: "on"
  action:
  # First, wait for the next heating-cycle to start (cycle-time Â± 75 minutes /
  # on-demand when warm water is used)
  - wait_for_trigger:
    - platform: numeric_state
      entity_id: sensor.power_57
      above: 1000
      for: "00:00:10"
    timeout: "03:00:00"
    continue_on_timeout: false
  # Then, wait for the boiler to become inactive for a while (i.e. heating-cycle
  # completed / no warm water being used) â€“ this way, we always switch off the
  # boiler when it's full of warm water, ensuring warm water remains available
  # until approximately midnight...
  - wait_for_trigger:
    - platform: numeric_state
      entity_id: sensor.power_57
      below: 50
      for: "00:15:00"
    timeout: "01:30:00"
    continue_on_timeout: false
  - service: switch.turn_off
    data: {}
    entity_id: switch.smart_plug_9
  mode: single
- alias: ðŸŒ¡ï¸ | âœˆï¸ Close-in boiler off (everyone away)
  description: ''
  trigger:
  - platform: state
    entity_id: group.family
    from: home
    to: not_home
  condition:
  - condition: state
    entity_id: switch.smart_plug_9
    state: "on"
  action:
  - service: switch.turn_off
    data: {}
    entity_id: switch.smart_plug_9
  mode: single
- alias: ðŸŒ¡ï¸ | ðŸ’¤/âœˆï¸ Close-in boiler on (everyone awake / someone home)
  description: ''
  trigger:
  - platform: state
    entity_id: input_boolean.everyone_asleep
    to: "off"
  - platform: state
    entity_id: group.family
    from: not_home
    to: home
  condition:
  - condition: state
    entity_id: switch.smart_plug_9
    state: "off"
  action:
  - service: switch.turn_on
    data: {}
    entity_id: switch.smart_plug_9
  mode: single
- alias: ðŸŒ¡ï¸ | â° Close-in boiler on (housekeeper comes when everyone away)
  description: ''
  # Using an input_datetime to store on which day of the week the housekeeper
  # comes â€“ compared against sensor.date (which changes daily at 00:00)
  trigger:
  - platform: template
    value_template: >-
      {{
        (
          state_attr("input_datetime.housekeeper_pre_arrival", "timestamp") |
            timestamp_custom("%w")
        ) == (states("sensor.date") | as_timestamp | timestamp_custom("%w"))
      }}
  condition:
  - condition: state
    entity_id: switch.smart_plug_9
    state: "off"
  - condition: state
    entity_id: group.family
    state: not_home
  action:
  # Use the same input_datetime to store at what time the housekeeper comes
  # (i.e. for how much to delay after 00:00)
  - delay: >-
      state_attr("input_datetime.housekeeper_pre_arrival", "timestamp") |
        timestamp_custom("%H:%M")
  # Only continue if the plug is still "off" (someone might've come home in the
  # meantime)
  - condition: state
    entity_id: switch.smart_plug_9
    state: "off"
  - service: switch.turn_on
    data: {}
    entity_id: switch.smart_plug_9
  - delay: "03:00:00"
  # Only continue if still no-one is home
  - condition: state
    entity_id: group.family
    state: not_home
  - service: switch.turn_off
    data: {}
    entity_id: switch.smart_plug_9
  mode: single
- alias: ðŸŒ¡ï¸ | â° Close-in boiler Legionella protection (twice-weekly when everyone away)
  description: ''
  trigger:
  - platform: time
    at: "02:00:00"
  condition:
  # On Tuesdays and Saturdays (i.e. twice-weekly)
  - condition: template
    value_template: >-
      {{ now().isoweekday() in [2, 6] }}
  - condition: state
    entity_id: switch.smart_plug_9
    state: "off"
  - condition: state
    entity_id: group.family
    state: not_home
  action:
  # Toggle on for three hours (i.e. at least two heating cycles) â€“ this should
  # heat the water sufficiently to prevent a Legionella hazard
  - service: switch.turn_on
    data: {}
    entity_id: switch.smart_plug_9
  - delay: "03:00:00"
  - service: switch.turn_off
    data: {}
    entity_id: switch.smart_plug_9
  mode: single
