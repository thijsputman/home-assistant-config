- alias: 📱 Sensor low battery notification (🔋 < 20%)
  id: bf5935e5-b716-4bfd-8949-71b01b4f484f
  variables:
    # Exclude mobile devices
    exclude:
      - sensor.p20hd_eea_battery_level
      - sensor.sm_g930f_battery_level
      - sensor.gm1913_battery_level
    # Courtesy of https://gist.github.com/sbyx/1f6f434f0903b872b84c4302637d0890
    sensors: >-
      {% set result = namespace(sensors=[]) %}
      {% for state in states.sensor |
          selectattr('attributes.device_class', '==', 'battery') %}
        {% if not state.entity_id in exclude and state.state | int(100) < 20 %}
            {% set result.sensors = result.sensors +
              [state.name ~ ': ' ~ state.state ~ '%'] %}
        {% endif %}
      {% endfor %}
      {{ result.sensors }}
  trigger:
    - platform: time
      at: "10:00:00"
  condition:
    # Only on Saturday if there are battery-levels below 20%
    - condition: template
      value_template: >-
        {{ now().isoweekday() == 6 and sensors | length > 0 }}
  action:
    - service: script.turn_on
      target:
        entity_id: script.persistent_notification
      data:
        variables:
          group: general
          channel: Notification
          targetDevices: my
          title: 🔋 Low sensor battery
          message: >-
            The following sensors have a battery level below 20%:
            <br><br>◾ {{
              sensors | join('<br>◾ ')
            -}}
  mode: single
- alias: 📱 Notify on integration failure (unknown/unavailable-state)
  id: 4c3d9da3-51c8-4881-9df0-8dec257d6d12
  description: ""
  variables:
    # Entities that require Internet-connectivity to function
    online:
      - !secret tado_ib1_connection_state
      - !secret tado_wr1_connection_state
      - !secret tado_wr2_connection_state
      - !secret aarlo_connected_sensor
      - vacuum.neato_d7
      - switch.pi_hole
  trigger:
    - platform: state
      entity_id:
        - sensor.power_consumption
        - sensor.weewx_outside_temperature
        - sensor.weewx_outside_temperature_balcony
        - !secret tado_ib1_connection_state
        - !secret tado_wr1_connection_state
        - !secret tado_wr2_connection_state
        - climate.tado_smart_thermostat
        - !secret aarlo_connected_sensor
        - vacuum.neato_d7
        - switch.pi_hole
        - binary_sensor.ds1815_security_status
        - media_player.pi0_speaker_bedroom
        - media_player.nvidia_shield_tv
        - sensor.pi4_1_minute_load
        - sensor.pi4_sandbox_1_minute_load
        - sensor.dvb_t_signal_strength
        - sensor.gammu_signal_strength
        # For deCONZ, Hue, Broadlink and Xiaomi Miot (respectively) monitor a
        # single sensor/device and assume its state is respective for that of
        # the entire integration. Might cause false positives, but there doesn't
        # appear to be a better way of handling this...
        - sensor.power_88
        - sensor.hue_dimmer_switch_1_battery_level
        - remote.broadlink_living_room_remote
        - sensor.qingping_air_monitor_lite_living_room_environment_co2_density
      to:
        - unknown
        - unavailable
      for: "00:10:00"
    # Gas consumption updates once per hour
    - platform: state
      entity_id: sensor.gas_consumption
      to:
        - unknown
        - unavailable
      for: "01:00:00"
    # Mi Flora (MQTT) sensors stop updating altogether – the light/lux
    # measurements appear most variable (they keep changing slightly, even when
    # it's dark). If they stop changing, most probably the bt-mqtt-gateway
    # has failed...
    - platform: state
      entity_id:
        - sensor.miflora_strelitzia_attic_light
        - sensor.miflora_bonsai_living_room_light
        - sensor.miflora_calathea_living_room_light
      for: "04:00:00"
  condition:
    # We should either be online (i.e. the Remote UI is connected), or the
    # entity in question should _not_ require Internet-connectivity to function
    - condition: or
      conditions:
        - condition: state
          entity_id: binary_sensor.remote_ui
          state: "on"
        - condition: template
          value_template: >-
            {{ trigger.entity_id not in online }}
  action:
    - service: script.turn_on
      target:
        entity_id: script.persistent_notification
      data:
        variables:
          group: general
          channel: Notification
          tag: >-
            {{ context.id }}
          targetDevices: my
          title: 💥 Potential integration failure
          message: >-
            {{ trigger.to_state.name }} has been in an
            {{ trigger.to_state.state }}-state for
            {{ relative_time(trigger.to_state.last_changed) }}.
    # Dismiss notification if/when the failure clears
    - wait_for_trigger:
        - platform: template
          value_template: >-
            {{
              states(trigger.to_state.entity_id)
                not in ['unknown', 'unavailable']
            }}
          for: "00:10:00"
      timeout: "12:00:00"
      continue_on_timeout: false
    - service: persistent_notification.dismiss
      data:
        notification_id: >-
          {{ context.id }}
  mode: parallel
  max: 10
# The Recorder's SQLite-database is on a separate NVMe USB-drive that – although
# generally stable – occasionally disconnects. It reconnects right away and the
# filesystem is automatically remounted, but Docker doesn't take very kindly to
# this: All containers using the volume need to be stopped and only then (once
# they're all down) restarted for the volume to become accessible again...
# The Raspberry Pi 4 is quite picky where it comes to its USB-drives: The one
# I'm currently using has historically been stable (not 100% though, which is
# why it's not the boot-volume). Recently I've discovered that – given the right
# atmospheric conditions – touching it causes a static shock which reconnects
# the drive... ⚡
- alias: 📱 Notify on Recorder-component failure (System Log)
  id: 28b00ed1-a3b0-4d7f-97bc-b1faf3b446d1
  trigger:
    platform: event
    event_type: system_log_event
    event_data:
      level: ERROR
      name: homeassistant.components.recorder
  condition: []
  action:
    # Explicitly block any further runs of this automation while the
    # notification is up (i.e. once a notification is up, no additional
    # notifications are raised)
    - service: script.persistent_notification
      data:
        group: general
        channel: Alert
        targetDevices: my
        criticalNotification: true
        title: 💽 Recorder-component failure!
        message: >-
          The recorder-component failed with the folllowing error:
          <br><br>
          {{ trigger.event.data.message }}
  mode: single
  max_exceeded: silent
# To prevent trigger-based template sensors from ending up in an "unknown"
# state after reloading the "Template Entities" configuration, fire a
# "template_reloaded" event shortly after this happens so that these sensors
# can trigger to update themselves
- alias: >-
    🚧 Trigger template_reloaded-event
    ("Template Entities" configuration reloaded)
  id: bc006b3a-0ea9-4596-9521-b6424a986872
  trigger:
    - platform: event
      event_type: call_service
      event_data:
        domain: template
        service: reload
  condition: []
  action:
    - delay: 30
    - event: template_reloaded
  mode: restart
- alias: 📱/🚨 | ⚡ Notify on prolonged power outage (⏰ > 10 minutes)
  id: 8ff8c413-b877-41af-bc9d-8e72b1b9bcab
  trigger:
    - platform: state
      entity_id: binary_sensor.power_outage
      to: "on"
      for: "00:10:00"
  condition:
    # If Home Alarm is "Armed away", a different – more immediate – response is
    # issued...
    - condition: not
      conditions:
        - condition: state
          entity_id: alarm_control_panel.home_alarm
          state: armed_away
  action:
    - service: script.turn_on
      target:
        entity_id: script.sms_notification
      data:
        variables:
          targetDevices: my
          message: >-
            ⚡ There appears to be a power outage!
            {% if states.sensor.ups_status is defined -%}
              \nHome Assistant has been running on back-up battery power for {{
                  relative_time(states.sensor.ups_status.last_changed)
                }} and has {{
                  states('sensor.ups_battery_runtime_minutes')
                }} minutes of runtime remaining...
            {%- endif -%}
    # If someone is home, also sound the alarm. The ZigBee controller is
    # connected to the UPS; the sirens have backup batteries so most likely
    # this'll work... 🤞
    - condition: state
      entity_id: group.family
      state: home
    - service: script.turn_on
      target:
        entity_id: script.sirens
      data:
        # Short pulses for 2 minutes; just to get people's attention
        variables:
          mode: pulse
          ontime: 120
  mode: single
- alias: 📱 | 📡 Notify on loss of (Internet-)connectivity
  id: aef11607-656e-41cc-8eb8-f2f18959ebeb
  trigger:
    - platform: state
      entity_id: binary_sensor.google_dns_ping
      from: "on"
      to: "off"
      for: "00:02:00"
    - platform: state
      entity_id: binary_sensor.remote_ui
      from: "on"
      to: "off"
      for: "00:02:00"
  action:
    - service: script.sms_notification
      data:
        targetDevices: my
        message: >-
          {%- if trigger.to_state.entity_id == 'binary_sensor.remote_ui' -%}
            📡 Home Assistant lost connectivity!
            \nHome Assistant appears to have lost connection with Nabu Casa.
          {%-
            elif trigger.to_state.entity_id == 'binary_sensor.google_dns_ping'
          -%}
            📡 Home Assistant lost Internet-connectivity!
            \nHome Assistant is unable to ping Google's Public DNS.
          {%- endif %} To inspect the state of the house:
          \n\n✉️ #secret# status [camera]
          \n\nTo check and control the Home Alarm:
          \n\n✉️ #secret# alarm [arm|disarm|silence]
    # Wait for connectivity to be restored – simultaneously blocks subsequent
    # connectivity triggers from resending the SMS
    - wait_for_trigger:
        - platform: template
          value_template: >-
            {{ states(trigger.to_state.entity_id) == 'on' }}
          for: "00:02:00"
      timeout: "12:00:00"
      continue_on_timeout: false
    - service: script.sms_notification
      data:
        targetDevices: my
        message: >-
          📡 Home Assistant connectivity restored
  mode: single
  max_exceeded: silent
# Stop Home Assistant (mainly to prevent database corruption) if a power failure
# appears imminent
- alias: 🚧 | 🔋 Stop Home Assistant (UPS 🔋 < 10%)
  id: e7dcf99d-a13d-43ed-a828-d19335c94787
  trigger:
    - platform: numeric_state
      entity_id: sensor.ups_battery_charge
      below: 10
  condition:
    # This intentionally does _not_ use "binary_sensor.power_outage" as the
    # below truly relies on the UPS and acts independent from the generalised
    # concept of a power outage...
    - condition: state
      entity_id: sensor.ups_status
      state: On Battery Battery Discharging
  action:
    # Block on sending the SMS notification (to prevent shutting down Home
    # Assistant before the message is send)
    - service: script.sms_notification
      data:
        targetDevices: my
        message: >-
          🔋 UPS low power!
          \nUPS battery level below 10%; power failure appears imminent –
          stopping Home Assistant...
    - service: system_log.write
      data:
        level: critical
        message: >-
          UPS battery level below 10%; power failure appears imminent –
          stopping Home Assistant...
    - service: homeassistant.stop
  mode: single
