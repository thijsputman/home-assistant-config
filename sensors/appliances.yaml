# (Ab?)using the Utility Meter to measure consumption/costs of a select number
# appliances

- platform: template
  sensors:
    # Close-in Boiler (Kitchen)
    monthly_consumption_costs_boiler_kitchen:
      friendly_name: Monthly costs (Close-in boiler – Kitchen)
      unit_of_measurement: €
      # Runs mostly during peak-hours, use peak-rate to approximate costs
      value_template: >-
        {{
          (
            (states('sensor.monthly_consumption_boiler_kitchen')|float *
              states('input_number.rate_energy_peak')|float)
          ) | round(2)
        }}
      attribute_templates:
        last_period: >-
          {{
            (
              (state_attr('sensor.monthly_consumption_boiler_kitchen',
                  'last_period')|float *
                states('input_number.rate_energy_peak')|float)
            ) | round(2)
          }}
    # Electric heater (Shed)
    monthly_consumption_costs_heater_shed:
      friendly_name: Monthly costs  (Electric heater – Shed)
      unit_of_measurement: €
      # Runs all-day round, use average of the two rates to approximate costs
      value_template: >-
        {{
          (
            (states('sensor.monthly_consumption_heater_shed')|float *
              (states('input_number.rate_energy_peak')|float +
              states('input_number.rate_energy_offpeak')|float) / 2)
          ) | round(2)
        }}
      attribute_templates:
        last_period: >-
          {{
            (
              (state_attr('sensor.monthly_consumption_heater_shed',
                  'last_period')|float *
                (states('input_number.rate_energy_peak')|float +
                states('input_number.rate_energy_offpeak')|float) / 2)
            ) | round(2)
          }}
    # Washing machine
    monthly_consumption_costs_washing_machine:
      friendly_name: Monthly costs (Washing machine)
      unit_of_measurement: €
      # Runs mostly off-peak, use that rate to approximate
      value_template: >-
        {{
          (
            (states('sensor.monthly_consumption_washing_machine')|float *
              states('input_number.rate_energy_offpeak')|float)
          ) | round(2)
        }}
      attribute_templates:
        last_period: >-
          {{
            (
              (state_attr('sensor.monthly_consumption_washing_machine',
                  'last_period')|float *
                states('input_number.rate_energy_offpeak')|float)
            ) | round(2)
          }}
    monthly_consumption_costs_dryer:
      friendly_name: Monthly costs (Dryer)
      unit_of_measurement: €
      # Runs mostly off-peak, use that rate to approximate
      value_template: >-
        {{
          (
            (states('sensor.monthly_consumption_dryer')|float *
              states('input_number.rate_energy_offpeak')|float)
          ) | round(2)
        }}
      attribute_templates:
        last_period: >-
          {{
            (
              (state_attr('sensor.monthly_consumption_dryer',
                  'last_period')|float *
                states('input_number.rate_energy_offpeak')|float)
            ) | round(2)
          }}
    # Dishwasher
    power_dishwasher_actual:
      friendly_name: Power (Dishwasher) [actual]
      unit_of_measurement: W
      # Dishwasher and Close-in boiler share the same outlet – "Diswasher"
      # measures both devices; "Close-in boiler" only the boiler. They use two
      # different types of smart-plug (one 10A, one 16A – otherwise their
      # combined load might overload the plug).
      # This leads to a wonderful issue: The measurements don't line up, both
      # in value and over time (the 16A Blitzwolf lags behind the – vastly
      # superior – 10A Xiaomi-unit).
      # We cope with this by ignoring the 16A unit (this one / dishwasher) if
      # the 10A unit _is_ drawing substantial power (indicating the boiler is
      # heating) or _was_ drawing power in the last 3 minutes (indicated by not
      # drawing power now and having its state changed within the last 2
      # minutes). The 3 minute-window has (empirically) been determined to
      # be the minimum delay required to not get errant spikes/measurements from
      # the Blitzwolf-unit.
      # As the power strip both devices are connected to prevents the boiler
      # from drawing substantial power when the dishwasher is doing so, the
      # approximation mostly holds. The time discrepancy is managable as the
      # boiler draws power in infrequent and short bursts which are unlikely
      # to greatly influence the overall dishwasher measurement.
      # Hindsight being 20/20: Probably would've been _much_ easier to get two
      # Xiaomi-units and connect both from the power strip instead of one from
      # the wall outlet. Ah well, for the future...
      value_template: >-
        {%- if states.sensor.power_57 is defined -%}
          {%- if states('sensor.power_57')|float > 1000 or
            (
              states('sensor.power_57')|float <= 1 and
                states.sensor.power_57.last_changed|as_local +
                  timedelta(minutes=3) >
                states.sensor.power_57.last_changed.utcnow()|as_local
            )
          -%}
            {{ 0.0|float }}
          {%- else -%}
            {{
              states('sensor.power_88_actual')|float
            }}
          {%- endif -%}
        {%- else -%}
          {{ 0.0|float }}
        {%- endif -%}
    monthly_consumption_dishwasher_actual:
      friendly_name: Monthly consumption (Dishwasher) [actual]
      unit_of_measurement: kWh
      value_template: >-
        {{
          states('sensor.monthly_consumption_dishwasher')|float -
            states('sensor.monthly_consumption_boiler_kitchen')|float
        }}
      attribute_templates:
        last_period: >-
          {{
            state_attr('sensor.monthly_consumption_dishwasher',
              'last_period')|float -
              state_attr('sensor.monthly_consumption_boiler_kitchen',
                'last_period')|float
          }}
    consumption_dishwasher_actual:
      friendly_name: Consumption (Dishwasher) [actual]
      unit_of_measurement: kWh
      # In absolute terms this number is nonsensical: Both consumption counters
      # are cumulative and didn't start at the same time (so the absolute number
      # starts out negative). It's used to graph daily usage (i.e. the delta
      # with yesterday – for that purpose it works just fine).
      # Additionally, this measurement most likely slightly overshoots reality
      # as the the Blitzwolf-plug has a lower resolution than the Xiaomi-plug
      # and will thus accumulate a bit more than we substract here (i.e. it
      # counts the same peak in usage longer than the Xiaomi-plug does). See the
      # comment at "sensor.power_dishwasher_actual" for more details.
      # And then, the Blitzwolf-plug takes a couple minutes to report its first
      # consumption data-point after Home Assistant start. To prevent a downward
      # spike after every HA restart, wait with the compution until the value
      # is actually available.
      value_template: >-
        {%- if states('sensor.consumption_87_actual')|float > 0.0 -%}
          {{
            states('sensor.consumption_87_actual')|float -
            states('sensor.consumption_58')|float
          }}
        {%- else -%}
          {{ states('sensor.consumption_87_actual') }}
        {%- endif -%}
    monthly_consumption_costs_dishwasher:
      friendly_name: Monthly costs (Dishwasher)
      unit_of_measurement: €
      # Runs mostly off-peak, use that rate to approximate
      value_template: >-
        {{
          (
            (states('sensor.monthly_consumption_dishwasher_actual')|float *
              states('input_number.rate_energy_offpeak')|float)
          ) | round(2)
        }}
      attribute_templates:
        last_period: >-
          {{
            (
              (state_attr('sensor.monthly_consumption_dishwasher_actual',
                  'last_period')|float *
                states('input_number.rate_energy_offpeak')|float)
            ) | round(2)
          }}
